<!DOCTYPE html> <html> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Les approches d'explicabilité des LLMs | Camille Barboule </title> <meta name="author" content="Camille Barboule"> <meta name="description" content="Méthodes d'explicabilité de la génération de texte par les LLMs"> <meta name="keywords" content="NLP, IR, Agents, Deep-Learning, XAI"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%F0%9F%93%9A&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://camillebrl.github.io/blog/2025/explainability_llm_generation/"> <script src="/assets/js/theme.js?a81d82887dd692e91686b43de4542f18"></script> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script>
    initTheme();
  </script> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightbox2@2.11.5/dist/css/lightbox.min.css" integrity="sha256-uypRbsAiJcFInM/ndyI/JHpzNe6DtUNXaWEUWEPfMGo=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@5.4.4/dist/photoswipe.min.css" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/spotlight.js@0.7.8/dist/css/spotlight.min.css" integrity="sha256-Dsvkx8BU8ntk9Iv+4sCkgHRynYSQQFP6gJfBN5STFLY=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/venobox@2.1.8/dist/venobox.min.css" integrity="sha256-ohJEB0/WsBOdBD+gQO/MGfyJSbTUI8OOLbQGdkxD6Cg=" crossorigin="anonymous"> <script src="/assets/js/distillpub/template.v2.js"></script> <script src="/assets/js/distillpub/transforms.v2.js"></script> <style>.toc-list{list-style:none;padding-left:0}.toc-list ul{list-style:none;padding-left:1.5em}.toc-list li{margin:.5em 0}.toc-list a{text-decoration:none;color:inherit}.toc-list a:hover{text-decoration:underline}d-article>*:first-child{margin-top:0!important}d-contents+h1,d-contents+h2,d-contents+h3,d-contents+h4,d-contents+h5,d-contents+h6,d-contents+p{margin-top:2rem!important}</style> </head> <body> <d-front-matter> <script async type="text/json">
      {
            "title": "Les approches d'explicabilité des LLMs",
            "description": "Méthodes d'explicabilité de la génération de texte par les LLMs",
            "published": "July 02, 2025",
            "authors": [
              
            ],
            "katex": {
              "delimiters": [
                {
                  "left": "$",
                  "right": "$",
                  "display": false
                },
                {
                  "left": "$$",
                  "right": "$$",
                  "display": true
                }
              ]
            }
          }
    </script> </d-front-matter> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Camille</span> Barboule </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item active"> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/books/">bookshelf</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="nav-item"> <button id="search-toggle" title="Search" onclick="openSearchModal()"> <span class="nav-link">ctrl k <i class="ti ti-search"></i></span> </button> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="ti ti-sun-moon" id="light-toggle-system"></i> <i class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled" id="light-toggle-light"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="post distill"> <d-title> <h1>Les approches d'explicabilité des LLMs</h1> <p>Méthodes d'explicabilité de la génération de texte par les LLMs</p> </d-title> <d-article> <d-contents> <nav class="l-text figcaption"> <h3>Contents</h3> <div id="toc-container" class="toc-list"> </div> </nav> </d-contents> <p>Un LLM génère des tokens à partir d’autres tokens selon un processus probabiliste. <mark>Pour chaque séquence de tokens fournie en entrée, le modèle retourne une distribution de probabilité sur l'ensemble des tokens suivants possibles</mark>. Un token représente un élément du vocabulaire du modèle, dont la taille est fixe et définie dans la configuration du tokenizer ou du modèle lui-même. Prenons l’exemple des modèles Qwen avec un <mark>vocabulaire de 151 936 tokens : à chaque étape de génération, le modèle calcule une distribution de probabilité sur ces 151 936 possibilités</mark>. De manière autorégressive, chaque nouveau token généré est ajouté à la séquence d’entrée pour prédire le suivant, et ainsi de suite. <mark>Comprendre pourquoi un modèle génère certains tokens plutôt que d'autres soulève plusieurs questions cruciales</mark>. La séquence d’entrée (prompt) peut contenir des éléments variés, notamment des chunks de texte dans le cas du RAG (Retrieval-Augmented Generation), qui servent de contexte pour répondre aux questions. Pour véritablement comprendre le processus de génération, nous devons répondre à trois interrogations principales :</p> <ul> <li> <mark>Quelles parties spécifiques du prompt influencent la génération de quels tokens ?</mark> Cette question est particulièrement pertinente dans le contexte du RAG où différents passages peuvent avoir des impacts variés sur la réponse finale.</li> <li> <mark>Sur quelles connaissances acquises pendant l'entraînement le modèle s'appuie-t-il pour générer chaque token ?</mark> Comment distinguer ce qui provient du prompt de ce qui provient de la mémoire du modèle ?</li> <li> <mark>Quelles parties du modèle (couches, têtes d'attention, neurones) sont responsables de quelles décisions ?</mark> Pourquoi des modèles de tailles différentes, même issus de la même famille, produisent-ils des réponses différentes ? Pour répondre à ces questions, nous devons nous tourner vers les approches d’explicabilité. Nous pouvons classifier les approches d’explicabilité des LLMs en 4 “familles”, comme présentées dans le papier <a href="https://arxiv.org/pdf/2506.05451" rel="external nofollow noopener" target="_blank">Interpretation Meets Safety: A Survey on Interpretation Methods and Tools for Improving LLM Safety</a>:</li> </ul> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/survey-480.webp 480w,/assets/img/explainability_llms/survey-800.webp 800w,/assets/img/explainability_llms/survey-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/survey.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide1-480.webp 480w,/assets/img/explainability_llms/slide1-800.webp 800w,/assets/img/explainability_llms/slide1-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide1.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>celles de <mark>"training data attribution" (ou "training" dans l'image), identifiant les données d'entraînement qui ont un fort impact (positif ou négatif) sur la génération du LLM</mark> , notamment à l’aides des fonctions d’influence,</li> <li>celles de <mark>"context attribution" (ou "input" dans l'image), identifiant quelles parties des données d'entrée (input) a un impact sur quelle partie de la génération du LLM</mark> (à l’aide des cartes de saillance et des cartes d’attention notamment),</li> <li>celles d’<mark>explicabilité mécanistique (ou "inference" dans l'image), consistant à trouver les circuits / éléments du LLM qui capturent certains concepts</mark>, avec des circuits identifiés par approches d’observation de l’espace latent (ACP sur les états cachés du LLM à différents niveaux du réseau), de dictionnary learning pour visualiser quels concepts sont capturés par chaque neurones / groupes de neurones, ou par “patching”, en modifiant certains états cachés pour voir l’effet sur le modèle.</li> <li>Celles <mark>étudiant la génération des modèles (ou "generation" dans l'image), notamment des modèles dits de "raisonnement" (thinking) qui détaillent leur raisonnement dans la réponse qu'ils fournissent</mark> : cette approche est d’autant plus utile aujourd’hui que les agents consistent en plusieurs appels du LLMs (un appel qui retourne un appel à un outil (tool), un autre qui retourne l’appel à un autre outil, etc).</li> </ul> <p>Nous allons <mark>d'abord observer les approches d'explicabilité par les données, que ce soit par les données d'entraînement ou par les données d'input (du prompt)</mark>. L’objectif est d’établir des liens causaux clairs entre ces sources de données et les tokens générés, qu’ils soient pris individuellement ou en groupes de tokens.</p> <h1 id="i-approches-tda-training-data-attribution-pour-comprendre-quelles-connaissances-apprises-dans-lentraînement-ont-été-influentes-dans-la-génération-de-quels-tokens">I/ Approches TDA (training data attribution) pour comprendre quelles connaissances apprises dans l’entraînement ont été influentes dans la génération de quels tokens</h1> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide2.PNG" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide2.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide3-480.webp 480w,/assets/img/explainability_llms/slide3-800.webp 800w,/assets/img/explainability_llms/slide3-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide3.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide4-480.webp 480w,/assets/img/explainability_llms/slide4-800.webp 800w,/assets/img/explainability_llms/slide4-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide4.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide5-480.webp 480w,/assets/img/explainability_llms/slide5-800.webp 800w,/assets/img/explainability_llms/slide5-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide5.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="1-les-fonctions-dinfluence-pour-estimer-limpact-dun-exemple-dentraînement-sur-la-prédiction-dun-exemple-de-test">1. Les fonctions d’influence pour estimer l’impact d’un exemple d’entraînement sur la prédiction d’un exemple de test</h2> <p>Si on cherche à estimer l’<mark>impact qu'aurait un exemple d'entraînement sur la perte d'un exemple de test (ou sur plusieurs résultats du modèle sur un jeu de données test) à un exemple d'entraînement</mark> (qu’il soit dans le jeu de données d’entraînement de base ou pas), on peut utiliser les fonctions d’influence.</p> \[\mathrm{Influence}\bigl(z_{\mathrm{train}}\to z_{\mathrm{test}}\bigr) = \frac{d}{d\varepsilon}\, \mathcal{L}\bigl(z_{\rm test},\,\theta_\varepsilon(z_\text{train})\bigr)\Big|_{\varepsilon=0} = -\nabla_\theta \,\mathcal{L}\bigl(z_{\mathrm{test}},\,\hat{\theta} \bigr)\,H_\theta^{-1}(\hat{\theta})\,\nabla_\theta \mathcal{L}(z_{\rm train},\hat{\theta})\] \[\mathrm{Influence}\bigl(z_{\mathrm{train}}\to f(x)\bigr) = \left.\frac{d}{d\varepsilon}\bigl(f_{\theta_{\varepsilon}(z_{\mathrm{train}})}(x)\bigr)\right|_{\varepsilon=0} = - \nabla_\theta f_{\hat{\theta}}(x)^\top \, H_\theta(\hat{\theta})^{-1} \, \nabla_\theta \mathcal{L}\bigl(x_{\mathrm{train}},\hat{\theta}\bigr)\] <p>Pour voir l’explication de la formule et plus de détails sur comment c’est utilisé dans les LLMs, vous pouvez aller voir <a href="camillebrl.github.io/blog/2025/influence_functions_applied_to_llms/">ce post</a>.</p> <p>La librairie <a href="https://github.com/pomonam/kronfluence" rel="external nofollow noopener" target="_blank">Kronfluence</a> permet de calculer l’influence dans le cas des LLMs. Des repo github proposent des tutos pour plusieurs de libs de calcul de l’influence dans les modèles de deep learning, comme <a href="https://github.com/deel-ai/influenciae" rel="external nofollow noopener" target="_blank">Influenciae</a> (btw, c’est une lib d’un labo de Toulouse!). Les fonctions d’influence permettent de répondre à ce genre de questions:</p> <ul> <li>Est-ce que je devrais <mark>ajouter cet exemple dans mon set d'apprentissage pour améliorer les performances de cette prédiction?</mark> </li> <li>Quels <mark>exemples d'entraînement ont été utiles à la prédiction</mark> de mon modèle?</li> <li>Le modèle s’est trompé: sur quels exemples d’entraînement s’est-il basé pour cette mauvaise prédiction?</li> </ul> <h2 id="2-les-approches-dattribution-aux-données-dentraînement-par-similarité-sémantique">2. Les approches d’attribution aux données d’entraînement par similarité sémantique</h2> <p>Pour trouver les données d’entraînement influentes pour la génération du LLM, on peut également simplement étudier la similarité sémantique entre la génération du LLM et les données d’entraînement.</p> <p>Le papier <a href="https://aclanthology.org/2024.blackboxnlp-1.33.pdf" rel="external nofollow noopener" target="_blank">Wrapper Boxes: Faithful Attribution of Model Predictions to Training Data</a> compare l’embedding de la génération du LLM à celui de la penultième couche, et entraîne ensuite trois types de « wrapper boxes » sur ces embeddings:</p> <ul> <li>un k-nearest neighbors (kNN) pour retrouver, à chaque inférence, les k exemples d’entraînement les plus proches ;</li> <li>un clustering k-means pour assigner l’input à un cluster dont on peut exposer le centroïde et les exemples qui le composent ;</li> <li>un arbre de décision dont chaque feuille correspond à un sous-ensemble d’exemples d’entraînement utilisés pour la classification.</li> </ul> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration de Wrapper Boxes</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/wrapper_boxes-480.webp 480w,/assets/img/explainability_llms/wrapper_boxes-800.webp 800w,/assets/img/explainability_llms/wrapper_boxes-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/wrapper_boxes.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <h2 id="3-les-approches-dattribution-aux-données-dentraînement-basées-sur-le-gradient">3. Les approches d’attribution aux données d’entraînement basées sur le gradient</h2> <p>Ces approches sont <mark>ressemblantes mais différentes des fonctions d'influence classiques, qu'on a vu plus tôt</mark>. En effet, ces fonctions d’influence calculent comment la perte sur un échantillon test, ou comment une fonction du modèle sur un échantillon donné changerait si on retirait / up-weightait un échantillon d’entraînement. Ici, les approches basées sur le gradient utilisent une notion plus simple: on <mark>calcule la distance entre 2 gradients</mark>: celui de la loss sur l’échantillon d’entraînement dont on veut voir l’influence avec celui de la loss sur l’exemple cible sur lequel on veut mesurer l’influence. Il y a plusieurs façons de calculer la distance entre les gradients: par produit scalaire, distance cosinus, …</p> <p>Le papier <a href="https://arxiv.org/pdf/2502.11411" rel="external nofollow noopener" target="_blank">Detecting and Filtering Unsafe Training Data via Data Attribution</a> identifie les données d’entraînement “unsafe” à l’aide d’une distance cosinus entre les gradients d’un exemple “unsafe” et des exemples du jeu d’entraînement:</p> \[\begin{split} \text{DABUF-inf}(z_\text{train}, z\text{target}) &amp;= \eta \cdot \cos(\nabla L(z_\text{target}; \theta), \nabla L(z_\text{train}; \theta)) \\ &amp;= \eta \cdot \frac{\nabla L(z_\text{target}; \theta) \cdot \nabla L(z_\text{train}; \theta)}{||\nabla L(z_\text{target}; \theta)|| \cdot ||\nabla L(z_\text{train}; \theta)||} \end{split}\] <p>On a aussi <a href="https://github.com/frederick0329/TracIn" rel="external nofollow noopener" target="_blank">TracIn</a>, qui lui ne calcule pas la distance cosinus entre les gradient mais effectue un produit scalaire entre eux.</p> <h2 id="4-les-approches-dattribution-aux-données-dentraînement-basées-sur-les-valeurs-de-shapley">4. Les approches d’attribution aux données d’entraînement basées sur les valeurs de Shapley</h2> <p>les valeurs de shapley estiment l’effet moyen de sous-ensembles d’un dataset en supprimant certaines variables explicatives (ici, certains datapoints du dataset) et en mesurant la différence de prédiction du modèle, puis en moyennant ces effets marginaux sur toutes les permutations possibles.</p> <p>L’utilisation des valeurs de Shapley pour déterminer la contribution de datapoints à la prédiction du modèle peut être vue comme une évaluation des contributions marginales <a href="https://arxiv.org/pdf/2110.14049" rel="external nofollow noopener" target="_blank">Beta Shapley: a Unified and Noise-reduced Data Valuation Framework for Machine Learning</a>. La contribution marginale d’un point de données $z_i$ à un sous-ensemble de taille $k$ de l’ensemble d’entraînement est définie comme:</p> \[\Delta^{D_N}_{z_i}(k, D_T) := \frac{1}{\binom{n-1}{k}} \sum_{\substack{S \subseteq N \setminus \{i\} \\ |S|=k}} \bigl(U(S\cup\{i\},D_T) - U(S,D_T)\bigr).\] <p>L’approche Leave-one-out (cf fonctions d’influences plus haut) considère la variation de la précision du modèle lorsqu’on retire le point cible de l’ensemble d’entraînement. Cette LOO peut être interprétée comme la contribution marginale de $z_i$ à $D_N\setminus{z_i}$. Les approches “leave-one-out” ou ses approximations (comme les fonctions d’influence, cf plus haut), ne considèrent que la contribution marginale de $z_i$ à un unique sous-ensemble de taille $n-1$ (avec $n$ étant la taille du jeu d’entraînement du modèle). Ainsi, le score d’instance d’un exemple chute fortement lorsqu’un autre exemple similaire apparaît dans l’ensemble d’entraînement (cf papier <a href="https://arxiv.org/pdf/1904.02868" rel="external nofollow noopener" target="_blank">Data Shapley: Equitable Valuation of Data for Machine Learning</a>), ce qui réduit la fiabilité et la robustesse de la mesure.</p> <p>Au lieu de ne considérer qu’un sous-ensemble, la valeur de Shapley la généralise en tenant compte de l’impact de $z_i$ sur tous les sous-ensembles. En gros, au lieu de considérer: \(g^{\mathrm{LOO}}(z_i, D_T, D_N) = \Delta^{D_N}_{z_i}(n-1, D_T).\) On considère: \(g^{\mathrm{Shap}}(z_i, D_T, D_N) = n^{-1} \sum_{k=0}^{n-1} \Delta^{D_N}_{z_i}(k, D_T).\) Ceci peut être vu comme la moyenne des contributions marginales de $z_i$ à des sous-ensembles de toutes tailles possibles.</p> <p>Cependant, calculer la valeur de Shapley sur un ensemble d’entraînement de taille $n$ exige un nombre exponentiel d’ajustements du modèle (soit $n!$), ce qui nécessite ajustements lorsque les datasets sont très grands (comme pour les LLMs).</p> <p>Le papier <a href="https://openreview.net/pdf?id=WSpPC1Jm0p" rel="external nofollow noopener" target="_blank">Helpful or Harmful Data? Fine-tuning-free Shapley Attribution for Explaining Language Model Predictions</a> propose une méthode d’attribution aux données d’entraînement basée sur les valeurs de Shapley, appelée FreeShap (Fine-tuning-free Shapley Attribution), basée sur la théorie du noyau tangent neuronal (NTK) pour éviter de multiples réentraînements du modèle.</p> <p>En effet, la théorie du noyau tangent neuronal (NTK) a été proposée pour étudier la dynamique d’entraînement des réseaux de neurone. Les travaux <a href="https://arxiv.org/pdf/1904.11955" rel="external nofollow noopener" target="_blank">On Exact Computation with an Infinitely Wide Neural Net</a> et <a href="https://www.researchgate.net/publication/339642345_Toward_a_theory_of_optimization_for_over-parameterized_systems_of_non-linear_equations_the_lessons_of_deep_learning" rel="external nofollow noopener" target="_blank">Toward a theory of optimization for over-parameterized systems of non-linear equations: the lessons of deep learning</a> montrent que l’entraînement d’un réseau entièrement suffisamment large est équivalent à la résolution d’une régression par noyau avec le NTK à l’initialisation aléatoire. Cependant, deux défis se posent lorsque l’on applique la théorie NTK au fine-tuning des LMs : (1) l’utilisation quasi systématique de poids préentraînés au lieu d’une initialisation aléatoire ; (2) l’emploi de prompts. Le papier de 2023 <a href="https://arxiv.org/pdf/2210.05643" rel="external nofollow noopener" target="_blank">A Kernel-Based View of Language Model Fine-Tuning</a> étend l’analyse pour montrer que résoudre la régression par noyau avec le NTK empirique (eNTK) calculé à partir des poids préentraînés peut reproduire le fine-tuning basé sur des prompts. De plus, la régression par noyau utilisant l’eNTK obtient des performances comparables au fine-tuning en computer vision (cf le papier <a href="https://arxiv.org/pdf/2203.06176" rel="external nofollow noopener" target="_blank">More Than a Toy: Random Matrix Models Predict How Real-World Neural Representations Generalize</a>) et en NLP (cf papier <a href="https://arxiv.org/pdf/2210.05643" rel="external nofollow noopener" target="_blank">A Kernel-Based View of Language Model Fine-Tuning</a>), ce qui en fait un substitut prometteur.</p> <p>L’eNTK se calcule à partir du Jacobien de la sortie du modèle pour un point de données $x_i$ : \(\psi(x_i)\;:=\;\frac{\partial f(x_i;\theta_0)}{\partial \theta_0} \;\in\;\mathbb{R}^{C\times P},\) où $\theta_0\in\mathbb{R}^P$ désigne les poids préentraînés.<br> Pour un ensemble d’entraînement $D_S$ d’indices $S:={1,\dots,k}$, on pose \(X_S \;:=\; \begin{bmatrix}x_1 \\ \vdots \\ x_k\end{bmatrix} \in\mathbb{R}^{k\times d}, \quad Y_S \;:=\; \begin{bmatrix} y^1_1 &amp; \cdots &amp; y^C_1 \\ \vdots &amp; &amp; \vdots \\ y^1_k &amp; \cdots &amp; y^C_k \end{bmatrix} \;\in\;\{0,1\}^{k\times C},\) où $y^p_j=1$ si la classe réelle de $x_j$ est $p$.<br> Une instance de test $x_t$ est alors prédite par le modèle de régression eNTK : \(f_S^{\mathrm{eNTK}}(x_t) \;=\; K(x_t, X_S)^\top \,K(X_S, X_S)^{-1}\, Y_S, \tag{5}\) avec \(K(x_t, X_S) =\bigl[\psi(x_t)\,\psi(x_i)^\top\bigr]_{i=1}^k \;\in\;\mathbb{R}^{C\times k}, \quad K(X_S, X_S) =\bigl[\psi(x_i)\,\psi(x_j)^\top\bigr]_{i,j=1}^k \;\in\;\mathbb{R}^{kC\times kC}.\)</p> <h1 id="ii-approche-input-prompt-attribution-mesurer-sur-quelles-parties-de-linput-le-modèle-sest-basé-pour-faire-sa-prédiction">II/ Approche Input (prompt) attribution: mesurer sur quelles parties de l’input le modèle s’est basé pour faire sa prédiction</h1> <p>Ces approches consistent à attributer la génération du LLM à des tokens du prompt pour comprendre quel(s) token(s) est/sont responsable(s) de quelle(s) parties de la génération du LLM.</p> <p>Dans ce <a href="https://arxiv.org/pdf/2502.15886" rel="external nofollow noopener" target="_blank">papier: A Close Look at Decomposition-based XAI-Methods for Transformer Language Models, 2025</a>, ils comparent plusieurs approches (qu’on va détailler ci-dessous) de context / input attribution:</p> <details> <summary style="cursor: pointer;">Cliquez la comparaison des tokens du prompts influents sur la génération du LLM par différentes approches comme présentées dans le papier</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/comparison-480.webp 480w,/assets/img/explainability_llms/comparison-800.webp 800w,/assets/img/explainability_llms/comparison-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/comparison.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide6.PNG" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide6.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide7-480.webp 480w,/assets/img/explainability_llms/slide7-800.webp 800w,/assets/img/explainability_llms/slide7-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide7.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide8-480.webp 480w,/assets/img/explainability_llms/slide8-800.webp 800w,/assets/img/explainability_llms/slide8-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide8.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide9-480.webp 480w,/assets/img/explainability_llms/slide9-800.webp 800w,/assets/img/explainability_llms/slide9-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide9.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h2 id="1-les-approches-basées-sur-lattention">1. Les approches basées sur l’attention</h2> <p>Ces approches affichent les poids d’attention de chaque token générés par rapport aux tokens du prompt (cas auto-regressif). Des poids d’attention élevés signifient que le modèle a donné plus d’importance à ce token pour la génération du token en question.</p> <p>Cependant, les poids d’attention sont donnés dans le réseau au niveau de chaque tête d’attention. Il est compliqué d’obtenir une attention “globale” que le modèle donne aux tokens. En effet, les scores d’attention ne montrent que les connexions locales (au sein de chaque tête de chaque couche du réseau), et surtout, ces patterns d’attention ne donnent tel quel aucune information : il s’agit de patterns uniformes. Plusieurs approches visent donc à modéliser ce flux d’attention global à travers le réseau pour tracer l’influence de chaque token d’entrée sur les tokens prédits.</p> <p>Tout l’enjeu est d’arriver à mesurer, de manière la plus fidèle et informative possible, le flux d’attention au sein du réseau pour donner une vue globale de l’influence de chaque token d’entrée sur un token généré.</p> <h3 id="11-visualisation-du-llm-comme-un-graphe-dattentions-pour-obtenir-la-contribution-finale-du-token">1.1 Visualisation du LLM comme un graphe d’attentions pour obtenir la contribution finale du token</h3> <p>Le papier <a href="https://aclanthology.org/2020.acl-main.385.pdf" rel="external nofollow noopener" target="_blank">Quantifying Attention Flow in Transformers</a> propose deux approches: une d’attention rollout et une d’attention flow. Ces 2 approches modélisent le LLM comme un graphe d’attention et utilisent chacune une méthode différente pour calculer l’attention globale d’un token sur le token prédit.</p> <p>La première approche proposée est dite d’“attention rollout”. Elle consiste à multiplier récursivement les matrices d’attention à travers toutes les couches. L’idée est de représenter le LLM comme un graphe d’attentions: Si chaque arête représente la proportion d’information transférée, multiplier les poids le long d’un chemin donne le flux total.</p> <p>La seconde approche est dite d’“attention flow”, avec dans l’idée de traiter le graphe d’attention comme un réseau de flux (flow network). Il utilise un algorithme de flux maximum où les capacités des arêtes sont les poids d’attention. Dans cette approche, le poids d’un chemin est le minimum des poids (pas le produit).</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration des poids d'attention selon ces 2 méthodes</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/vis_attn-480.webp 480w,/assets/img/explainability_llms/vis_attn-800.webp 800w,/assets/img/explainability_llms/vis_attn-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/vis_attn.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <h3 id="12-la-contribution-globale-dun-token-associée-aux-logits-au-sein-des-différents-blocs-dattention-et-mlp">1.2 La contribution globale d’un token associée aux logits au sein des différents blocs d’attention (et MLP)</h3> <p>ALTI-Logit <a href="https://aclanthology.org/2023.acl-long.301.pdf" rel="external nofollow noopener" target="_blank">Explaining How Transformers Use Context to Build Predictions</a> suit comment chaque token d’entrée contribue à la prédiction finale en traversant le réseau, en prenant en compte la contribution de chaque élément au logit, ainsi que l’ensemble des transformations (notamment au niveau du MLP) réalisées sur les scores d’attention pour évaluer cette contribution. En gros, pour calculer la contribution finale d’un token, ALTI-logit trace comment ce token (au logit du mot évalué) se propage à travers les connexions d’attention et les connexions résiduelles de toutes les couches, en tenant compte du mélange d’information entre tokens à chaque étape.</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration la composition d'un block transformers</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/transformer_layer-480.webp 480w,/assets/img/explainability_llms/transformer_layer-800.webp 800w,/assets/img/explainability_llms/transformer_layer-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/transformer_layer.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> \[\begin{aligned} x^L_T &amp;= x^0 + \sum_{l=1}^L \Bigl(\Delta_{\mathrm{MHA}}^l + \Delta_{\mathrm{MLP}}^l\Bigr),\\ \Delta_{\mathrm{MHA}}^l &amp;= \text{contribution du bloc MHA de la couche }l,\\ \Delta_{\mathrm{MLP}}^l &amp;= \text{contribution du bloc MLP de la couche }l. \end{aligned}\] <p>Pour chaque couche $l$ : \(\begin{aligned} \Delta_{\mathrm{MLP}}^l &amp;= \mathrm{sortie}^l_{\mathrm{MLP}} \;-\; \mathrm{entrée}^l_{\mathrm{MLP}},\\ \mathrm{relevance}_{\mathrm{MLP}}^l &amp;= \Delta_{\mathrm{MLP}}^l \;\cdot\; U_w, \end{aligned}\) où $U_w$ est le vecteur d’unembedding de sortie pour le token suivant.</p> <p>\textbf{Exemple (couche 10)} : \(\begin{aligned} \mathrm{entrée}_{\mathrm{MLP}}^{10} &amp;= [0.1,\;0.2,\;\dots],&amp; \mathrm{sortie}_{\mathrm{MLP}}^{10} &amp;= [0.3,\;0.5,\;\dots],\\ \Delta_{\mathrm{MLP}}^{10} &amp;= [0.2,\;0.3,\;\dots],&amp; \Delta_{\mathrm{MLP}}^{10} \cdot \mathrm{embedding}_{\text{dort}} &amp;= 1.5. \end{aligned}\)</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration de ALTI-logit</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/alti_logit-480.webp 480w,/assets/img/explainability_llms/alti_logit-800.webp 800w,/assets/img/explainability_llms/alti_logit-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/alti_logit.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <h3 id="13-visualisation-de-lattention-sa-propagation-dans-le-réseau-comme-un-graphe-à-plusieurs-niveaux">1.3 Visualisation de l’attention (sa propagation dans le réseau) comme un graphe à plusieurs niveaux</h3> <p>On peut voir l’attention comme un graphe à plusieurs niveaux: en effet, il y a d’abord les tokens (premier niveau, groupe A) sur lequels le token prédit par le LLM porte son attention. Mais il y a ensuite les tokens sur lesquels les tokens du groupe A portent leur attention (second niveau, groupe B), et ainsi dessuite. On peut remonter ainsi l’attention à plusieurs niveaux.</p> <p>Afin d’identifier comment les tokens du prompt sont traitées par le LLM dans ses différentes têtes d’attention pour amener à l’output, le papier <a href="https://arxiv.org/pdf/2402.14811" rel="external nofollow noopener" target="_blank">Fine-Tuning Enhances Existing Mechanisms: A Case Study on Entity Tracking</a> teste d’abord toutes les têtes d’attention pour voir lesquelles, quand patchées (modification par une version bruitée de la tête d’attention: ici obtenue à l’aide de 2 fine-tuning différents: l’un bruité et l’autre d’origine), affectent le plus le logit final. Les têtes qui causent la plus grande chute de performance sont celles qui “regardent” directement la réponse correcte (Ces têtes forment le Groupe A). Le papier cherche ensuite quelles têtes d’attention ont un effet direct important sur les têtes du Groupe A, en patchant les chemins allant de candidats potentiels vers le Groupe A.</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration de l'approche de la propagation de l'attention par groupes</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/path_patching2-480.webp 480w,/assets/img/explainability_llms/path_patching2-800.webp 800w,/assets/img/explainability_llms/path_patching2-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/path_patching2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <p>Le papier <a href="https://arxiv.org/pdf/2502.01951" rel="external nofollow noopener" target="_blank">On the Emergence of Position Bias in Transformers</a> représente en effet le masque d’attention comme un graphe $G$ dirigé où:</p> <ul> <li>Les nœuds représentent les tokens de la séquence</li> <li>une arrête $(j,i) \in E(G)$ signifie que l’attention du token $i$ est portée sur le token $j$</li> </ul> <p>La propagation de l’information au sein des différentes couches du réseau se fait comme cela:</p> <p>Pour une couche unique: \(X^{(1)} = A^{(0)}X^{(0)}W_V^{(0)}\), Pour 2 couches: \(X^{(2)} = A^{(1)}A^{(0)}X^{(0)}W_V^{(0)}W_V^{(1)}\) Pour t couches: \(X^{(t+1)}_{i,:} = \sum_{j=1}^{N} \underbrace{(A^{(t)} \cdots A^{(0)})_{ij}}_{P^{(t)}(z_i=j|X^{(0)})} \cdot \underbrace{X^{(0)}_{j,:} W_V^{(0)} \cdots W_V^{(t)}}_{f^{(t)}(X^{(0)}_{z_i,:})}\)</p> <p>Le produit cumulatif $P^{(t)} = A^{(t)} \cdots A^{(0)}$ représente la probabilité cumulative que le token $i$ sélectionne le token $j$ comme contexte après $t$ couches. Cela capture tous les chemins possibles de longueur $t+1$ entre les tokens $j$ et $i$ dans le graphe.</p> <p>Le papier <a href="https://aclanthology.org/2024.emnlp-main.731.pdf" rel="external nofollow noopener" target="_blank">Chain and Causal Attention for Efficient Entity Tracking</a> généralise ce pattern d’attention “multi-niveau” en proposant un nouveau mécanisme d’attention qui, en une seule couche, permet toutes les connexions d’attention précédemment faites entre les couches. Pour cela, il utilise une représentation formelle avec le produit cumulatif des matrices d’attention qui permet de capturer toutes les longueurs de chemins en une seule couche. En effet, le papier interprète la matrice d’attention $A$ comme une matrice d’adjacence d’un graphe dirigé pour capturer toutes les dépendances possibles : \(A + A^2 + A^3 + \cdots = A(I - A)^{-1}\), avec $A$ connexions directes (chemins de longueur 1), $A^2$ chemins de longueur 2, $A^3$ chemins de longueur 3, etc. L’attention qu’ils proposent est calculée comme :</p> \[\boxed{Y = (1 - \gamma) \cdot A(I - \gamma A)^{-1}V}\] <p>où $\gamma \in [0, 1)$ est un hyperparamètre qui assure la convergence de la série $A + \gamma A^2 + \gamma^2 A^3 + \cdots$ et permet l’interpolation entre attention standard ($\gamma = 0$) et ChaCAL ($\gamma \approx 1$).</p> <h3 id="14-intérêt-des-approches-basées-sur-lattention-facilement-manipulables-pour-forcer-le-modèle-à-porter--ne-pas-porter-son-attention-sur-certains-tokens">1.4 Intérêt des approches basées sur l’attention: “facilement” manipulables pour “forcer” le modèle à porter / ne pas porter son attention sur certains tokens</h3> <p>Le papier <a href="https://openreview.net/pdf?id=xZDWO0oejD" rel="external nofollow noopener" target="_blank">Tell Your Model Where to Attend: Post-hoc Attention Steering for LLMs</a> force l’attention du LLM vers des parties spécifiques du prompt désignées par l’utilisateur, à la manière dont nous utilisons le gras ou l’italique dans les textes humains pour diriger l’attention du lecteur.</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration de l'approche PASTA</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/pasta-480.webp 480w,/assets/img/explainability_llms/pasta-800.webp 800w,/assets/img/explainability_llms/pasta-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/pasta.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <p>Le papier <a href="https://arxiv.org/pdf/2502.09674" rel="external nofollow noopener" target="_blank">The Hidden Dimensions of LLM Alignment: A Multi-Dimensional Analysis of Orthogonal Safety Directions</a> propose une approche plus complexe, pour neutraliser l’attention sur les tokens déclencheurs de jailbreak, qu’il identifie en exploitant la structure multi-dimensionnelle de l’espace résiduel de sécurité, construit comme la transformation linéaire des activations pendant le safety fine-tuning. Les tokens déclencheurs sont identifiés non pas par une seule direction, mais par l’interaction entre une direction dominante qui prédit le comportement de refus global, et plusieurs directions non-dominantes qui capturent des patterns spécifiques de jailbreak. Ces directions sont extraites via SVD de la matrice représentant les changements d’activation.</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration du papier du "safety residual space"</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/safe_direction-480.webp 480w,/assets/img/explainability_llms/safe_direction-800.webp 800w,/assets/img/explainability_llms/safe_direction-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/safe_direction.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <p>Cependant, ces approches basées sur l’attention pour mesurer l’importance d’un token du prompt sur la génération du modèle sont limitéesn puisque même si le modèle porte une attention plus forte à un token donné, cela ne veut pas nécessairement dire que ce token exerce une influence plus importante sur les logits. C’est pour ça que les apprioches basées sur le gradient ont plus de sens pour mesurer l’impact des tokens du prompt sur la génération du modèle:</p> <h2 id="2-approches-basées-sur-le-gradient-les-cartes-de-saillance-saliency-maps">2. Approches basées sur le gradient: les cartes de saillance (saliency maps)</h2> <p>Ces approches mesurent comment la sortie du modèle $f(x)$ varie si on modifie chaque token $x_i$ de l’entrée.</p> <p>Plus précisément, les tokens étant représentés par des embeddings de dimension $d_{\text{model}}$, <mark>on calcule le gradient de $f(x)$ par rapport à chaque dimension de l'embedding de chaque token $x_i$</mark>. On obtient donc, pour chaque token, un vecteur gradient de dimension $d_{\text{model}}$. Pour obtenir un score de saillance scalaire par token, on <mark>agrège ces $d_{\text{model}}$ gradients à l'aide de différentes méthodes</mark> :</p> <ul> <li>Norme L2 : $|\nabla_{x_i} f(x)|_2$</li> <li>Norme L1 (somme des valeurs absolues) : $|\nabla_{x_i} f(x)|_1$</li> <li>Produit scalaire avec l’embedding : $\nabla_{x_i} f(x) \cdot x_i$</li> </ul> <p>Pour se faire, des libraires comme <a href="https://github.com/pytorch/captum" rel="external nofollow noopener" target="_blank">Captum</a> ou <a href="https://github.com/inseq-team/inseq" rel="external nofollow noopener" target="_blank">Inseq</a> ou <a href="https://github.com/jacobgil/pytorch-grad-cam" rel="external nofollow noopener" target="_blank">Grad-cam</a> ou <a href="https://github.com/albermax/innvestigate" rel="external nofollow noopener" target="_blank">Investigate</a> ou <a href="https://github.com/SeldonIO/alibi" rel="external nofollow noopener" target="_blank">Alibi</a> existent.</p> <p>J’ai créé un <a href="https://github.com/camillebrl/mirage_ui" rel="external nofollow noopener" target="_blank">repo github</a> qui reproduit un <a href="https://aclanthology.org/2024.emnlp-main.347.pdf" rel="external nofollow noopener" target="_blank">papier (MIRAGE)</a> d’explication de la génération du modèle à partir des éléments du prompt, découpés document par document (cas du RAG).</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/mirage_illustration-480.webp 480w,/assets/img/explainability_llms/mirage_illustration-800.webp 800w,/assets/img/explainability_llms/mirage_illustration-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/mirage_illustration.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Ici, on parle d’attribution de l’importance des tokens du prompt dans la génération du LLM par calcul de gradient, c’est à dire simplement en dérivant la sortie du LLM par rapport aux tokens du prompt. Le problème, c’est que quand la fonction est localement plate (gradient nul), l’attribution est nulle même si l’input est important. L’approche des gradients intégrés (IG) (introduits dans le papier <a href="https://arxiv.org/pdf/1703.01365" rel="external nofollow noopener" target="_blank">Axiomatic Attribution for Deep Networks</a>), résout ces problèmes en intégrant les gradients le long d’un chemin entre une baseline neutre et l’input réel.</p> <p>Soit $x = (x_1, x_2, …, x_n)$ le vecteur d’embeddings correspondant aux tokens du prompt, et $x’ = (x’_1, x’_2, …, x’_n)$ une baseline neutre (typiquement des embeddings nuls ou des tokens de padding). Pour un modèle $F$ produisant une sortie $y = F(x)$, l’importance du $i$-ème token est calculée par :</p> \[IG_i(x) = (x_i - x'_i) \times \int_{\alpha=0}^{1} \frac{\partial F(x' + \alpha \times (x - x'))}{\partial x_i} d\alpha\] <p>Cette formule capture l’accumulation des gradients lorsqu’on interpole linéairement entre la baseline $x’$ et l’entrée réelle $x$. Le terme $(x_i - x’_i)$ représente la différence entre l’embedding du token réel et celui de la baseline, tandis que l’intégrale accumule les sensibilités du modèle tout au long du chemin d’interpolation.</p> <p>En pratique, l’intégrale est approximée par une somme de Riemann (cas discret) :</p> \[IG_i(x) \approx (x_i - x'_i) \times \sum_{k=1}^{m} \frac{\partial F(x' + \frac{k}{m} \times (x - x'))}{\partial x_i} \times \frac{1}{m}\] <p>où $m$ est le nombre de pas d’intégration. Cette méthode garantit deux propriétés importantes : la sensibilité (un token n’ayant aucun impact aura une attribution nulle) et la complétude (la somme des attributions égale la différence entre les sorties du modèle pour l’entrée réelle et la baseline).</p> <p>Le papier <a href="https://aclanthology.org/2024.findings-emnlp.551.pdf" rel="external nofollow noopener" target="_blank">Barkan et al., Improving LLM Attributions with Randomized Path-Integration, 2024</a> améliore la méthode des gradients intégrés (IG) en introduisant de la randomisation dans le processus d’intégration pour générer de meilleures attributions. En effet, contrairement à IG qui intègre les gradients par rapport aux embeddings d’entrée, RPI intègre les gradients par rapport aux scores d’attention du modèle. Ainsi, pour chaque couche, il calcule les gradients de la prédiction par rapport au tenseur d’attention interpolé le long d’un chemin randomisé entre une baseline aléatoire et les scores d’attention réels.</p> <h2 id="3-approches-basées-sur-les-vecteurs-décomposition-des-représentations-intermédiaires-faites-par-le-llm-de-chaque-token-du-prompt-avec-acp">3. Approches basées sur les vecteurs: décomposition des représentations intermédiaires faites par le LLM de chaque token du prompt avec ACP</h2> <p>Une autre approche consiste à étudier l’espace latent (c’est à dire les représentations intermédiaires (à différents niveaux du réseau) du LLM) des tokens d’entrée pour étudier cet espace : comment une perturbation de cet espace modifie la génération du LLM? Comment est structuré cet espace? Est-ce qu’en modifiant / étudiant les directions de cet espace je peux en déduire quelque chose sur la sortie du LLM?</p> <p>Le papier <a href="https://arxiv.org/pdf/2310.17191" rel="external nofollow noopener" target="_blank">How do Language Models Bind Entities in Context?</a> par exemple utilise des perturbations sur les représentations intermédiaires des tokens du prompt pour voir leur impact sur la génération du LLM.</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration du papier binding ids, perturbant les représentations intermédiaires des tokens du prompt pour voir l'impact sur la génération du LLM</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/binding_ids-480.webp 480w,/assets/img/explainability_llms/binding_ids-800.webp 800w,/assets/img/explainability_llms/binding_ids-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/binding_ids.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <p>Le papier <a href="https://arxiv.org/pdf/2407.12831" rel="external nofollow noopener" target="_blank">Truth is Universal: Robust Detection of Lies in LLMs</a> effectue quand à lui une ACP sur les représentations intermédiaires du dernier token de chaque phrase (le “.”) - le modèle étudié étant autorégressif, le dernier token encode la globalité de la phrase. Ils effectuent cette ACP sur les représentations intermédiaires d’un ensemble de données comprenant des phrases vraies (triangles orange dans les figures) et fausses (carrés violets), qu’ils avaient annotées au préalable. Ils observent deux directions principales qui émergent de cette analyse : une direction “générale de vérité” (tG) qui sépare efficacement les déclarations vraies des fausses indépendamment de leur polarité (affirmative ou négative), et une direction “sensible à la polarité” (tP) qui distingue les phrases affirmatives des phrases négatives. Dans l’espace d’activation du modèle, tG pointe systématiquement des déclarations fausses vers les vraies, indépendamment de la polarité grammaticale (affirmative/négative). On peut donc prédire si la génération du LLM va être une hallucination ou non à l’aide de cet espace.</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration du papier qui fait l'ACP sur les représentations intermédiaires d'un ensemble de prompts vrai et faux</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/acp_true_false_statements.PNG" sizes="95vw"></source> <img src="/assets/img/explainability_llms/acp_true_false_statements.PNG" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <h1 id="iii-les-approches-dexplicabilité-mécanistique-inférence-comprendre-quelle-partie-du-llm-est-responsable-de-quel-concept">III/ Les approches d’explicabilité mécanistique (inférence): comprendre quelle partie du LLM est responsable de quel concept</h1> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide10-480.webp 480w,/assets/img/explainability_llms/slide10-800.webp 800w,/assets/img/explainability_llms/slide10-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide10.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide11-480.webp 480w,/assets/img/explainability_llms/slide11-800.webp 800w,/assets/img/explainability_llms/slide11-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide11.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide12-480.webp 480w,/assets/img/explainability_llms/slide12-800.webp 800w,/assets/img/explainability_llms/slide12-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide12.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Le papier <a href="https://arxiv.org/pdf/2501.16496" rel="external nofollow noopener" target="_blank">Open Problems in Mechanistic Interpretability</a> décrit tous les défis / enjeux d’explicabilité mécanistique.</p> <h2 id="1-les-sondes-sur-lespace-latent">1. Les sondes sur l’espace latent</h2> <p>Ces approches consistent à étudier l’espace latent du modèle en lui donnant différents concepts en entrée (les “sondes”).</p> <h3 id="11-les-approches-de-sonde-par-ablation-de-lespace-latent">1.1 Les approches de sonde par ablation de l’espace latent</h3> <p>L’ablation de l’espace latent consiste à une mise à zéro ou suppression d’une activation.</p> <ul> <li>Ablation de couches, têtes d’attention ou paramètres</li> <li>Localisation de composants responsables :</li> <li>Hallucinations : Jin et al. (2024), Li et al. (2024a)</li> <li>Jailbreaks : Zhao et al. (2024d), Wei et al. (2024)</li> <li>Biais : Yang et al. (2023b), Ma et al. (2023)</li> </ul> <h3 id="12-les-approches-de-sonde-par-patching-de-lespace-latent">1.2 Les approches de sonde par patching de l’espace latent</h3> <p>Le patching consiste à remplacer une activation par une autre.</p> <ul> <li>Inspiré de l’analyse de médiation causale (Pearl, 2001)</li> <li>Remplacement d’activations intermédiaires</li> <li>Applications : Hallucinations (Monea et al., 2024), biais (Vig et al., 2020)</li> </ul> <p>Pour étudier les circuits:</p> <ul> <li>Path patching : Wang et al. (2023), Goldowsky-Dill et al. (2023)</li> </ul> <h3 id="13-les-approches-de-sonde-par-observation-réduction-de-dimension-et-autre-de-lespace-latent">1.3 Les approches de sonde par observation (réduction de dimension et autre) de l’espace latent</h3> <p>Il s’agit de projections de l’espace latent calculé sur différents concepts. On affiche donc les représentations des tokens / phrases avec et sans un concept spécifique, pour essayer de trouver un élément de l’espace latent qui les sépare.</p> <p>Pour se faire, on peut effectuer une moyenne des vecteurs appartenant à un certain concept (hallucinations (<a href="https://aclanthology.org/2024.emnlp-main.1012.pdf" rel="external nofollow noopener" target="_blank">Liu et al., On the Universal Truthfulness Hyperplane Inside LLMs</a>, 2024), jailbreaks (<a href="https://arxiv.org/pdf/2406.11717" rel="external nofollow noopener" target="_blank">Arditi et al. Refusal in Language Models Is Mediated by a Single Direction, 2024</a>)), ou encore des méthodes de réduction de dimension de l’espace latent, comme l’ACP (<a href="https://arxiv.org/pdf/2402.09733" rel="external nofollow noopener" target="_blank">Duan et al., Do LLMs Know about Hallucination? An Empirical Investigation of LLM’s Hidden States</a>). D’autres approches entraînent un classifier sur les représentations de l’espace latent (Détection d’hallucinations <a href="https://arxiv.org/pdf/2212.03827" rel="external nofollow noopener" target="_blank">Burns et al., Discovering Latent Knowledge in Language Models Without Supervision, 2022</a>, <a href="https://arxiv.org/pdf/2407.12831" rel="external nofollow noopener" target="_blank">Truth is Universal: Robust Detection of Lies in LLMs, Bürger et al., 2024</a>, jailbreaks <a href="https://aclanthology.org/2024.findings-emnlp.139.pdf" rel="external nofollow noopener" target="_blank">Zhou et al., How Alignment and Jailbreak Work: Explain LLM Safety through Intermediate Hidden States, 2024</a>).</p> <p>Cependant, ces différents approches supposent que ces concepts sont encodés comme directions linéaires, alors que ce n’est pas vraiment le cas dans les LLMs.</p> <h3 id="14-ces-approches-permettent-de-corriger-le-modèle-en-dirigeant-dune-certaine-manière-les-vecteurs-latents">1.4 Ces approches permettent de “corriger” le modèle en dirigeant d’une certaine manière les vecteurs latents</h3> <p>cf: hallucinations <a href="https://arxiv.org/pdf/2306.03341" rel="external nofollow noopener" target="_blank">Li et al., Inference-Time Intervention: Eliciting Truthful Answers from a Language Model, 2023</a>, jailbreaks <a href="https://arxiv.org/pdf/2308.10248" rel="external nofollow noopener" target="_blank">Turner et al.,Steering Language Models With Activation Engineering, 2023</a></p> <p>Exemple des figures de ces papiers pour “corriger” le modèle selon ces direction:</p> <p>Le papier <a href="https://arxiv.org/pdf/2306.03341" rel="external nofollow noopener" target="_blank">Inference-Time Intervention: Eliciting Truthful Answers from a Language Model</a> propose cette approche:</p> <details> <summary style="cursor: pointer;">Cliquez pour voir l’illustration de l'intervention sur les activations du modèle</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/intervention-480.webp 480w,/assets/img/explainability_llms/intervention-800.webp 800w,/assets/img/explainability_llms/intervention-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/intervention.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <p>Le papier <a href="https://arxiv.org/pdf/2308.10248" rel="external nofollow noopener" target="_blank">Steering Language Models With Activation Engineering</a> propose cette approche:</p> <details> <summary style="cursor: pointer;">Cliquez pour voir une autre illustration d'une intervention sur les activations du modèle</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/intervention2-480.webp 480w,/assets/img/explainability_llms/intervention2-800.webp 800w,/assets/img/explainability_llms/intervention2-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/intervention2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <p>Le papier <a href="https://arxiv.org/pdf/2406.11717" rel="external nofollow noopener" target="_blank">Refusal in Language Models Is Mediated by a Single Direction</a> qui corrige les poids du modèle de la direction $r$ identifiée comme générant des jailbreaks : $x’ = x - rr^Tx$. L’<strong>ablation directionnelle</strong> « met à zéro » la composante suivant $r$ pour chaque activation du flux résiduel $x \in \mathbb{R}^{d_{\text{model}}}$.</p> <h2 id="12-les-auto-encodeurs-pour-apprendre-un-dictionnaire-des-éléments-du-réseau-sparse-dictionnary-learning">1.2 Les auto-encodeurs pour apprendre un “dictionnaire” des éléments du réseau (Sparse Dictionnary Learning)</h2> <p><strong>Analyse des neurones individuels</strong></p> <p><strong>Autoencodeurs épars (SAE)</strong></p> <ul> <li>Objectif : Désentrelement des concepts superposés</li> <li>Architecture : Encodeur → vecteur épars de concepts → Décodeur</li> <li> <strong>Références clés</strong> :</li> <li>Fondamentaux : Sharkey et al. (2022), Bricken et al. (2023)</li> <li>Améliorations : Rajamanoharan et al. (2024a), Templeton et al. (2024)</li> <li> <strong>Applications sécurité</strong> :</li> <li>Hallucinations : Ferrando et al. (2025), Theodorus et al. (2025)</li> <li>Jailbreaks : Härle et al. (2024), Muhamed et al. (2025)</li> <li>Biais : Hegde (2024), Zhou et al. (2025a)</li> </ul> <p><strong>Logit lens</strong></p> <ul> <li>Projection des vecteurs latents intermédiaires sur l’espace vocabulaire</li> <li>Origine : nostalgebraist (2020), Elhage et al. (2021)</li> <li>Améliorations : Belrose et al. (2023), Din et al. (2023)</li> <li>Applications : Mécanismes de stockage/rappel (Yu et al., 2023), hallucinations (Yu et al., 2024b)</li> </ul> <h3 id="121-le-principe-de-superposition--analyse-des-neurones-individuels">1.2.1 Le principe de superposition : Analyse des neurones individuels</h3> <p>Selon l’hypothèse de superposition, un réseau peut représenter plus de caractéristiques qu’il n’a de dimensions, à condition que chaque feature s’active de manière parcimonieuse. (chaque caractéristique (feature) d’un réseau de neurones ne doit pas être activée tout le temps, mais seulement dans des cas spécifiques et rares)</p> <p>Ces approches de SDL sont plus sophistiquées et “state of the art” que les approches de réduction de dimension avec ACP ou autre des activations, justement dû au fait de la polysémanticité des neurones. Si un neurone encode à la fois : “nature”, “vieux”, “lumière” dans un même sous-espace de représentation, l’ACP ne pourra pas dissocier ces trois concepts si leurs activations sont mélangées dans les mêmes dimensions.</p> <p>En gros, les activations sont traitées par un petit réseau neuronal à deux couches, correspondant respectivement à un encodeur et un décodeur, avec un espace latent large: L’encodeur encode l’activation de chaque variable latente, et le décodeur est une matrice qui sert de dictionnaire des directions latentes.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/superposition-480.webp 480w,/assets/img/explainability_llms/superposition-800.webp 800w,/assets/img/explainability_llms/superposition-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/superposition.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <ul> <li>Identification des entrées activant fortement un neurone</li> <li>Références : Geva et al. (2021), Foote et al. (2023)</li> <li>Défi : Polysémantique des neurones (Arora et al., 2018)</li> <li>Fondamentaux : Sharkey et al. (2022), Bricken et al. (2023)</li> <li>Améliorations : Rajamanoharan et al. (2024a), Templeton et al. (2024)</li> <li>Hallucinations : Ferrando et al. (2025), Theodorus et al. (2025)</li> <li>Jailbreaks : Härle et al. (2024), Muhamed et al. (2025)</li> <li>Biais : Hegde (2024), Zhou et al. (2025a)</li> </ul> <p>Il existe plusieurs approches de SDL, qui traitent des activations différentes:</p> <ul> <li>Les autoencodeurs parcimonieux (SAE) (classique)</li> <li>Les transcodeurs (cf papier <a href="https://openreview.net/pdf?id=J6zHcScAo0" rel="external nofollow noopener" target="_blank">Transcoders Find Interpretable LLM Feature Circuits</a>)</li> <li>Les crosscodeurs (cf article <a href="https://transformer-circuits.pub/2024/crosscoders/index.html" rel="external nofollow noopener" target="_blank">Sparse Crosscoders for Cross-Layer Features and Model Diffing</a>)</li> </ul> <h3 id="122-analyse-de-groupes-de-neurones-à-différents-niveaux-dans-le-réseau">1.2.2 Analyse de groupes de neurones à différents niveaux dans le réseau</h3> <p>Les concepts sont ici représentées non par par neurone mais sur plusieurs layers. Du coup, il est naturel d’appliquer l’apprentissage de dictionnaires de manière conjointe entre les layers. Les crosscodeurs permettent de gérer la persistance d’une feature sur plusieurs couches.</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/residual_stream-480.webp 480w,/assets/img/explainability_llms/residual_stream-800.webp 800w,/assets/img/explainability_llms/residual_stream-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/residual_stream.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/superposition2-480.webp 480w,/assets/img/explainability_llms/superposition2-800.webp 800w,/assets/img/explainability_llms/superposition2-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/superposition2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/crosscoder-480.webp 480w,/assets/img/explainability_llms/crosscoder-800.webp 800w,/assets/img/explainability_llms/crosscoder-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/crosscoder.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Les crosscodeurs peuvent nous aider en cas de superposition entre couches, mais ils peuvent également être utiles lorsqu’une feature calculée reste dans le flux résiduel pendant de nombreuses couches. Considérons le cycle de vie hypothétique suivant d’une feature à travers le flux résiduel :</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/crosscoder2-480.webp 480w,/assets/img/explainability_llms/crosscoder2-800.webp 800w,/assets/img/explainability_llms/crosscoder2-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/crosscoder2.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <h1 id="iv-les-approches-dexplicabilité-par-génération-de-raisonnement-du-llm">IV/ Les approches d’explicabilité par Génération de Raisonnement du LLM</h1> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide13-480.webp 480w,/assets/img/explainability_llms/slide13-800.webp 800w,/assets/img/explainability_llms/slide13-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide13.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/slide14-480.webp 480w,/assets/img/explainability_llms/slide14-800.webp 800w,/assets/img/explainability_llms/slide14-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/slide14.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Explorer comment les LLM peuvent interpréter leurs propres sorties en exprimant le raisonnement sous-jacent.</p> <h2 id="raisonnement-en-génération">Raisonnement en génération</h2> <h3 id="chain-of-thought-cot">Chain-of-Thought (CoT)</h3> <p>La Chain of Thought consiste à fournir, dans le prompt, quelques exemples de raisonnements détaillés pas-à-pas (“intermediate steps”), incitant le modèle à « penser à voix haute » avant de donner sa réponse.</p> <p>Plusieurs approches “améliorées” du CoT ont émergées:</p> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/cot_sota-480.webp 480w,/assets/img/explainability_llms/cot_sota-800.webp 800w,/assets/img/explainability_llms/cot_sota-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/cot_sota.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> <p>Il y a notamment le CoT-SC (Chain of Thought Self Consistency) qui consiste à choisir la réponse la plus fréquente ou la plus cohérente en agrégeant ces chemins de raisonnement issu du CoT, comme présenté dans le papier <a href="https://arxiv.org/pdf/2203.11171" rel="external nofollow noopener" target="_blank">Self-Consistency Improves Chain of Thought Reasoning in Language Models</a></p> <details> <summary style="cursor: pointer;">Cliquez pour voir une illustration du CoT-SC</summary> <figure> <picture> <source class="responsive-img-srcset" srcset="/assets/img/explainability_llms/cot_sc-480.webp 480w,/assets/img/explainability_llms/cot_sc-800.webp 800w,/assets/img/explainability_llms/cot_sc-1400.webp 1400w," type="image/webp" sizes="95vw"></source> <img src="/assets/img/explainability_llms/cot_sc.png" class="img-fluid rounded z-depth-1" width="100%" height="auto" data-zoomable="" loading="eager" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </details> <h4 id="extension-via-le-tree-of-thoughts-tot">Extension via le Tree of Thoughts (ToT)</h4> <p>Tree of Thoughts étend la CoT en explorant un arbre de pensées : à chaque nœud, le modèle génère plusieurs « thoughts » candidates, peut les évalue globalement, … <a href="https://arxiv.org/pdf/2305.10601" rel="external nofollow noopener" target="_blank">Tree of Thoughts: Deliberate Problem Solving with Large Language Models</a></p> <h4 id="combinaison-du-cot-et-de-lappel-de-tool-des-llms-cas-des-agents--react">Combinaison du CoT et de l’appel de tool des LLMs (cas des agents) : ReAct</h4> <p>Le paradigme ReAct combine raisonnement (traces de CoT) et actions (interrogation d’API, interaction avec un environnement) de façon intercalée, permettant de corriger en temps réel et de réduire l’hallucination.</p> <p><a href="https://arxiv.org/pdf/2210.03629" rel="external nofollow noopener" target="_blank">ReAct: Synergizing Reasoning and Acting in Language Models</a></p> <h4 id="autres-papiers-sur-le-sujet">Autres papiers sur le sujet</h4> <p>Quelques papiers intéressants sur le sujet: <a href="https://arxiv.org/pdf/2502.03671" rel="external nofollow noopener" target="_blank">Advancing Reasoning in Large Language Models: Promising Methods and Approaches</a> <a href="https://arxiv.org/pdf/2502.17419" rel="external nofollow noopener" target="_blank">From System 1 to System 2: A Survey of Reasoning Large Language Models</a> <a href="https://arxiv.org/pdf/2507.06203" rel="external nofollow noopener" target="_blank">A Survey on Latent Reasoning</a> <a href="https://arxiv.org/pdf/2505.16782" rel="external nofollow noopener" target="_blank">Reasoning Beyond Language: A Comprehensive Survey on Latent Chain-of-Thought Reasoning</a></p> </d-article> <d-appendix> <d-footnote-list></d-footnote-list> <d-citation-list></d-citation-list> </d-appendix> <d-bibliography src="/assets/bibliography/"></d-bibliography> <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;"> <script>
      let giscusTheme = determineComputedTheme();
      let giscusAttributes = {
        src: 'https://giscus.app/client.js',
        'data-repo': 'camillebrl/camillebrl.github.io',
        'data-repo-id': '',
        'data-category': 'Comments',
        'data-category-id': '',
        'data-mapping': 'title',
        'data-strict': '1',
        'data-reactions-enabled': '1',
        'data-emit-metadata': '0',
        'data-input-position': 'bottom',
        'data-theme': giscusTheme,
        'data-lang': 'en',
        crossorigin: 'anonymous',
        async: '',
      };

      let giscusScript = document.createElement('script');
      Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
      document.getElementById('giscus_thread').appendChild(giscusScript);
    </script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2025 Camille Barboule. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script> <script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script> <script defer src="/assets/js/copy_code.js?c8a01c11a92744d44b093fc3bda915df" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js" integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script> <script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6" crossorigin="anonymous"></script> <script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/lightbox2@2.11.5/dist/js/lightbox.min.js" integrity="sha256-A6jI5V9s1JznkWwsBaRK8kSeXLgIqQfxfnvdDOZEURY=" crossorigin="anonymous"></script> <script defer src="/assets/js/photoswipe-setup.js" type="module"></script> <script defer src="https://cdn.jsdelivr.net/npm/spotlight.js@0.7.8/dist/spotlight.bundle.min.js" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/venobox@2.1.8/dist/venobox.min.js" integrity="sha256-LsGXHsHMMmTcz3KqTaWvLv6ome+7pRiic2LPnzTfiSo=" crossorigin="anonymous"></script> <script defer src="/assets/js/venobox-setup.js?897c1d9c0b6fcf82b949511c1609d055" type="text/javascript"></script> <script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script> <script>
    addBackToTop();
  </script> <script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script> <ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys> <script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script> <script src="/assets/js/search-data.js"></script> <script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script> <script>
      document.addEventListener('DOMContentLoaded', function() {
        // Fonction pour créer un ID à partir du texte (compatible avec Jekyll slugify)
        function createId(text) {
          return text.trim()
            .toLowerCase()
            .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // Enlever les accents
            .replace(/[^\w\s-]/g, '') // Enlever les caractères spéciaux
            .replace(/\s+/g, '-') // Remplacer les espaces par des tirets
            .replace(/-+/g, '-') // Éviter les tirets multiples
            .replace(/^-|-$/g, ''); // Enlever les tirets au début et à la fin
        }
        
        // Fonction pour décoder et normaliser une ancre d'URL
        function normalizeAnchor(anchor) {
          try {
            // Décoder l'URL
            const decoded = decodeURIComponent(anchor);
            // Appliquer la même normalisation que createId
            return createId(decoded);
          } catch (e) {
            return anchor;
          }
        }
        
        // Récupérer tous les headers dans l'article
        const article = document.querySelector('d-article');
        const headers = article.querySelectorAll('h1, h2, h3, h4, h5, h6');
        const tocContainer = document.getElementById('toc-container');
        
        if (headers.length === 0) return;
        
        // Filtrer les headers pour exclure ceux dans d-contents et d-title
        const filteredHeaders = Array.from(headers).filter(header => {
          return !header.closest('d-contents') && !header.closest('d-title');
        });
        
        if (filteredHeaders.length === 0) return;
        
        // Structure pour construire la hiérarchie
        let currentList = document.createElement('ul');
        tocContainer.appendChild(currentList);
        
        let stack = [{level: 0, list: currentList}];
        
        filteredHeaders.forEach((header) => {
          // Ajouter un ID au header s'il n'en a pas
          if (!header.id) {
            header.id = createId(header.textContent);
          }
          
          // Déterminer le niveau (h1=1, h2=2, etc.)
          const level = parseInt(header.tagName.substring(1));
          
          // Gérer la hiérarchie
          while (stack.length > 1 && stack[stack.length - 1].level >= level) {
            stack.pop();
          }
          
          // Si on descend dans la hiérarchie
          if (stack[stack.length - 1].level < level) {
            const newList = document.createElement('ul');
            const lastItem = stack[stack.length - 1].list.lastElementChild;
            if (lastItem) {
              lastItem.appendChild(newList);
            } else {
              stack[stack.length - 1].list.appendChild(newList);
            }
            stack.push({level: level, list: newList});
          }
          
          // Créer l'élément de liste
          const listItem = document.createElement('li');
          const link = document.createElement('a');
          link.href = '#' + header.id;
          link.textContent = header.textContent;
          link.addEventListener('click', function(e) {
            e.preventDefault();
            header.scrollIntoView({ behavior: 'smooth', block: 'start' });
          });
          
          listItem.appendChild(link);
          stack[stack.length - 1].list.appendChild(listItem);
        });
        
        // Nettoyer les listes vides
        const emptyLists = tocContainer.querySelectorAll('ul:empty');
        emptyLists.forEach(list => list.remove());
        
        // Gérer la navigation depuis l'URL
        function navigateToHash() {
          if (window.location.hash) {
            const hash = window.location.hash.substring(1);
            const normalizedHash = normalizeAnchor(hash);
            
            // Essayer de trouver l'élément par ID normalisé
            let targetElement = document.getElementById(normalizedHash);
            
            // Si pas trouvé, essayer avec le hash original
            if (!targetElement) {
              targetElement = document.getElementById(hash);
            }
            
            // Si toujours pas trouvé, chercher dans tous les headers
            if (!targetElement) {
              filteredHeaders.forEach(header => {
                if (createId(header.textContent) === normalizedHash) {
                  targetElement = header;
                }
              });
            }
            
            if (targetElement) {
              setTimeout(() => {
                targetElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
              }, 100);
            }
          }
        }
        
        // Naviguer au chargement de la page
        navigateToHash();
        
        // Écouter les changements de hash
        window.addEventListener('hashchange', navigateToHash);
      });
    </script> </body> </html>